<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<HTML>
  <HEAD>
    <TITLE> Ghidra What's New</TITLE>
	<STYLE type="text/css" name="text/css">
		li { font-family:times new roman; font-size:14pt; font-family:times new roman; font-size:14pt; margin-bottom: 8px; }
		h1 { color:#000080; font-family:times new roman; font-size:28pt; font-style:italic; font-weight:bold; text-align:center; color:#000080; font-family:times new roman; }
		h2 { padding-top:10px; color:#984c4c; font-family:times new roman; color:#984c4c; font-family:times new roman; font-size:18pt; font-weight:bold; }
		h3 { margin-left:40px; padding-top:10px; font-family:times new roman; font-family:times new roman; font-size:14pt; font-weight:bold; }
		h4 { margin-left:40px; padding-top:10px; font-family:times new roman; font-family:times new roman; font-size:14pt; font-weight:bold; }
		p { margin-left:40px; font-family:times new roman; font-size:14pt; }
		table, th, td { border: 1px solid black; border-collapse: collapse; font-size:10pt; }
		td { font-family:times new roman; font-size:14pt; padding-left:10px; padding-right:10px; text-align:left; vertical-align:top; }
		th { font-family:times new roman; font-size:14pt; font-weight:bold; padding-left:10px; padding-right:10px; text-align:left; }
		code { color:black; font-family:courier new; font-size: 12pt; }
		span.code { font-family:courier new font-size: 14pt; color:#000000; }
	 </STYLE>
  </HEAD>

  <BODY>

	<H1>Ghidra: NSA Reverse Engineering Software</H2>
    
    <P>
    Ghidra is a software reverse engineering (SRE) framework developed by NSA's Research Directorate.
    This framework includes a suite of full-featured, high-end software analysis tools that enable
    users to analyze compiled code on a variety of platforms including Windows, MacOS, and Linux.
    Capabilities include disassembly, assembly, decompilation, debugging, emulation, graphing, and scripting, along with
    hundreds of other features.  Ghidra supports a wide variety of processor instruction sets and 
    executable formats and can be run in both user-interactive and automated modes.  Users may also
    develop their own Ghidra plug-in components and/or scripts using the exposed API.  In addition there are
    numerous ways to extend Ghidra such as new processors, loaders/exporters, automated analyzers,
    and new visualizations.
    </P>
    
    <P>
    In support of NSA's Cybersecurity mission, Ghidra was built to solve scaling and teaming problems
    on complex SRE efforts and to provide a customizable and extensible SRE research platform.  NSA
    has applied Ghidra SRE capabilities to a variety of problems that involve analyzing malicious
    code and generating deep insights for NSA analysts who seek a better understanding of potential
    vulnerabilities in networks and systems.
    </P>
    <hr>   
        
    <H1>What's New in Ghidra 10.3</H1>
    
    <H2>The not-so-fine print: Please Read!</H2>
    
	<P>Ghidra 10.3 is fully backward compatible with project data from previous releases.
	However, programs and data type archives which are created or modified in 10.3 will not be useable by an earlier Ghidra version. </P>

	<P>This release includes many new features and capabilities, performance improvements, quite a few bug fixes, and many pull-request
	contributions. Thanks to all those who have contributed their time, thoughts, and code. The Ghidra user community thanks you too!</P>
	
	<P>IMPORTANT: Ghidra requires Java 17 JDK to run.  A newer version of Java may be acceptable but has not been fully tested.  Please see the
	<a href="InstallationGuide.html">Ghidra Installation Guide</a> for additional information.</P>
	
	<P>NOTE: Please note that any programs imported with a Ghidra beta versions or code built directly from source outside of a release tag may not be compatible
	and may have flaws that won't be corrected by using this new release.  Any programs analyzed from a beta or other local master source build should be considered
	experimental and re-imported and analyzed with a release version.  As an example, Ghidra 10.1 beta had an import flaw affecting symbol demangling that was not
	correctable. Programs imported with previous release versions should upgrade correctly through various automatic upgrade mechanisms.  Any program
	you will continue to reverse engineer should be imported fresh with a release version or a build you trust with the latest code fixes.</P>

	<P>NOTE: Ghidra Server: The Ghidra 10.3 server is compatible with Ghidra 9.2 and later Ghidra clients.  Ghidra 10.3
	clients are compatible with all 10.x and 9.x servers.  Although, due to potential Java version differences, it is recommended
	that Ghidra Server installations older than 10.2 be upgraded.  Those using 10.2 and newer should not need a server upgrade.</P>
	
	<P>NOTE: Platform-specific native executables can be built directly from a release distribution.
	The distribution currently provides Linux 64-bit, Windows 64-bit, and MacOS x86 binaries.  If you have another platform,
	for example a MacOS M1 based system or a Linux variant, the support/buildNatives script can build the Decompiler,
	demangler, and legacy PDB executables for your plaform.  Please see "Building Ghidra Native Components" section in the
	the <a href="InstallationGuide.html#Build">Ghidra Installation Guide</a> for additional information.</P>
	
	<H2>Dark Mode / Theming </H2>
	
	<P>Ghidra now supports UI theming, which allows for full customization of colors, fonts, and icons used consistently throughout the application.
	Ghidra themes are built on top of the various Java Look and Feel classes.  Included are standard themes for all the supported
	Look and Feels. The most notable is the Flat Dark theme, which is built using the FlatLaf, a modern open-source flat Look and Feel
	library. Additionally, Ghidra includes various tools for editing and creating custom themes.</P>
	
	<P>Also, all the main display windows (Listing, Decompiler, and Bytes Viewer) support quickly changing the font size via <B>&lt;Ctrl&gt;+</B> or <B>&lt;Ctrl&gt;-</B>.</P>

    <P>See the Ghidra Help pages for full details on the theming feature.</P>
	
	<H2>Debugger</H2>
	
	<P>Perhaps the most exciting debugger change is the addition of new training course materials for the Debugger. The materials are written in
	Markdown so they display right on GitHub, but they can also be rendered to nice HTML pages by Pandoc for offline viewing. They are suitable
	both for self-paced learning and classroom environments. Even if you have used our Debugger before, we highly recommend reading these materials.
	They are in the <b>docs/GhidraClass</b> directory with the other course materials.</P>
	<P>There are several changes to improve the user experience with the Emulator:</P>
	<blockquote>
	<ul>
	<li>There is a dedicated Emulator tool. Previously, it was not apparent an Emulator GUI even existed in the Debugger tool. Most only
	accessed it via scripting. The Emulator tool is the same as the Debugger tool, but without the back-end debugger management plugins.
	This both showcases the Emulator and makes it safer to access, e.g., when examining malware. The launch buttons are removed, nearly
	eliminating the risk of accidental detonation.</li>
	<li>The control actions (step, suspend, resume, etc.) have been moved to the main toolbar. When toggled to control the emulator, it is now
	possible to emulate to the next breakpoint. Before, it was only possible to step. If you were savvy, you could use the <b>Go To Time</b>
	action to run many steps, but you had to predict precisely how many steps. These controls present the Emulator as a more traditional
	trap-and-trace debugger and retain support for time travel.</li>
	<li>Breakpoints are now applied to the Emulator. They also support injecting custom Sleigh semantics into the Emulator. This makes
	it possible, e.g., to stub out external function calls. Breakpoints are now displayed in the <b>Decompiler</b> margin, too. </li>
	<li>Regarding uninitialized/undefined memory, the Emulator will still treat undefined bytes as zeros. When decoding an
	instruction; however, it will now interrupt if when encounters undefined bytes. Previously, it would just decode them as if
	zeros, which was never useful. </li>
	<li>Nascent support for stack unwinding has been added. Up to now, we have relied on the back-end debugger to unwind the stack,
	which ruled out displaying accurate stack frames during emulation. There is still more work for full UI integration, but you can
	unwind a stack (whether on target or emulated) using the <b>Debugger -> Analysis</b> menu and view the results by navigating the
	<b>Dynamic Listing</b> to stack space. Please understand it may not work in most situations, yet.</li>
	<li>Several miscellaneous actions have been added: To invalidate the Emulator cache, use the Debugger -> Configure Emulator menu.
	Use this whenever the Emulator seems to be ignoring configuration changes, especially when modifying custom Sleigh breakpoints.
	To display all bytes (not just changed ones) in the Dynamic Listing, choose Load Bytes from Emulator in the Auto-Read drop-down.
	To manually add or remove memory regions, e.g., to create and initialize a heap for emulation, use the new actions in the Regions window</li>
	</ul>
	</blockquote>
	<P>There are several Debugger UI improvements: </P>
    <blockquote>
	<ul>
	<li>The control actions are duplicated in the main toolbar. Previously, these were only in the Objects window. (They remain there for
	back-end connector/model development, troubleshooting, and diagnostics.) The actions in the main toolbar can be toggled to control a
	live target or the Emulator. The Emulator stepping actions have been removed from the <b>Threads</b> panel. (They never really made sense there.)
	Toggling these actions to the Emulator effectively forks an emulator from the target's live state, i.e., for extrapolation, just as the old
	emulator stepping actions did.</li>
	<li>The current program counter is now displayed in the top right corner of the <b>Dynamic Listing</b> (or whatever the listing is configured to
	track). It will display in red if the address cannot be shown in the listing, e.g., because it is not mapped in memory. This provides better
	feedback when the listings seem to be out of sync.</li>
	<li>GDB's advance command has been added to the Listing context menus as well as the equivalent actions for other debuggers. (More generally,
	any command provided by a back-end connector that takes a single address parameter is presented in context menus where an address is
	available.)</li>
	<li>The <b>Go To dialog</b> in the <b>Dynamic Listing</b> can now take simple addresses in hexadecimal. Previously, it only took Sleigh expressions,
	which are powerful, but made the common case too complicated. It still accepts Sleigh expressions, and those expressions can now refer
	to labels (symbols) from any mapped program database (static image).</li>
	<li>A new kind of hover has been added for displayed variables. If there is a debugger target (live or emulated) mapped to the current program,
	the hover will display the variable's current value. This applies to Listings and the Decompiler window. </li>
	<li>You can now select a different thread, frame, or snapshot without activating it. Single-click to select. Double-click to activate.</li>
	</ul>
	</blockquote>
	<P>There are a few small improvements to back-end debugger integration: </P>
    <blockquote>
	<ul>
	<li>You can now set the working directory when launching a Windows target. </li>
	<li>GADP agents now accept a single connection and automatically terminate when Ghidra disconnects. </li>
	<li>Launch scripts have been added for starting a GADP agent from the command line.</li>
	<li>There is now a script to build the Java bindings needed for the LLDB connector. </li>
	</ul>
	</blockquote>
		
	<H2>Decompiler</H2>
	<P>Support has been added for expanding assignment statements on structures or arrays, where multiple fields or elements are moved as a
	group by a single instruction. This is especially helpful for analyzing structure initialization code and stack strings. </P>
	
	<P>Support continues to improve for structures that are either stored across multiple registers or in a single register that is
	accessed in pieces.  Data types associated with the component fields are propagated more fully throughout the function, and assignments
	to fields are displayed simply.</P>
	
	<H2>Data Types</H2>
	
	<P>Data Type Archives may now optionally target a specific architecture as specified by a processor and associated compiler specification
	such as data organization.  This has the advantage of better conveying datatype details for a desired architecture and preserving aspects
	which may change when resolved into a program.  In the future, this will also allow function definitions to retain architecture-specific
	details.</P> 

    <P>Function definition data types have been improved to preserve calling convention names which may differ from the predefined generic
    calling convention names to include those which may have originated from an extended compiler specification.   In addition, function
    definitions now support the noreturn attribute. </P>

    <P>Enum handling has been improved in the data type manager when creating new enums from an existing set of enum values,
    for example <b>define_</b> enums parsed from header files.  Enum values will be automatically sized to fit all the values contained
    in the enum.  Setting the size of an Enum will check if the values will fit within the new size.  In addition, <b>define_</b> values
    created as enums with a single value are sized to the minimum size to fit the value.  Parsed enums from header files are sized based
    on the declared size of an int from the data organization used to parse.  A future version will have a setting to size all parsed enums
    to the smallest size that will fit all the values. </P>
    
	<H2>C Header File Parsing </H2>
	<P>The C-Parser GUI has been refactored to remove include paths from the Options section done as <b>-D</b> define lines, to a new Include section.
	This should make it easier to configure paths to the include files and has the added benefit of coloring the include file entries red if
	they are not found within any include path.  You may find creating and using a Ghidra Script instead of the GUI an easier repeatable process.
	There are several included examples scripts, including ones to parse AVR8 header files, and Visual Studio version 22 files. </P>
	
	<P>All supplied data type archive GDT files, except macOS, have been re-parsed to include the new processor architecture. </P>
	
	<H2>Mach-O Binary Import</H2>
	<P>Mach-O binary analysis continues to improve. Support has been added for new file formats introduced in iOS 16 and macOS 13.
	Improvements have also been made to function identification, symbol detection, and Objective-C support. </P>
	
	<H2>Analysis</H2>

	<P>New <b>ApplyDataArchives</b> analyzer settings enable use of locally created GDT data type archive files or project archives in the
	analysis pipeline.  Used in conjunction with analysis options settings saved to a named analysis configuration you can easily switch to using a new
	GDT file and associated analysis options for a given type of binary.  For example, if you are working with AVR8 binaries and have
	an associated AVR8.gdt file, create an AVR8 configuration and it will be used as the default analysis options configuration until
	you change to a new configuration. </P>
	
	<P>Constant Propagation now deals with constants passed as stack parameters.  In addition, there are several new settings which can better
	control when a constant is considered to be an address.  For example, processors with small memory spaces, the setting <b>Require pointer param
	data type</b>, will only create a reference if the parameter is declared with a data type that would be a pointer.  This can be useful for Harvard
	architectures with multiple address spaces used in conjunction with the PointerTypedef to specify the address space of the pointer.  Currently,
	once you change the parameter of a called function to be a pointer, you will need to re-run analysis to get the constants passed to the function
	to be turned into a reference.  This will be automated in the near future. </P>
	
	<P>By default, pointer-to-pointer analysis is turned off for ARM binaries in the Operand and Data Reference analyzers. This can result in fewer
	references created and can be turned back on if your ARM binaries use pointers data stored in memory instead of offset values from the current PC
	to calculate all references.</P>
	
	<P>Added support for PE MinGW pseudo-relocation processing. </P>

    <H2>Shared Projects</H2>
    <P>Folder and file links to contents of another shared project repository may now be added to a Ghidra Project.  This could allow a team to
    include a program or subfolder that resides in another project rather than copying the program into your project for easy access.  The linked
    files are opened for read-only viewing. </P>
    
	<H2>Processors</H2>
	<P>Improvements and bug fixes have been made to many processors since 10.2 to include:
	<code>AARCH64, ARM, Coldfire, HCS12 MIPS X86, PowerPC, RISCV SPARC, SuperH, TriCore, V850, Z80, 6x09, 68K, and 8051</code>.</P>
	
	<P>Two new user-submitted processors, <code>eBPF</code> and <code>BPF</code>, add support for two variants of Berkeley Packet Filter binaries.</P>
	
	<P>A user-submitted refactoring of X86 <code>LOCK/UNLOCK</code> decoding and semantics has been committed. There are currently some issues with the
	Decompiler re-arranging code outside of the <code>LOCK/UNLOCK</code> which will be addressed with an upcoming patch. If your analysis depends on
	the LOCK/UNLOCK semantics, please be aware of the issue. </P>
	
	<P> A new leading zeroes count operator, called <code>lzcount</code>, has been added to p-code, and it can now be used by SLEIGH developers
	to model processor instructions.  The Decompiler can simplify common code idioms using these instructions, and emulation is supported.</P>
	
	<H2>User Interface Improvements</H2>
	<P>Diff can now be performed between two open programs which may include remote files previously opened via a Ghidra-URL. </P>
	
	<H2>GoLang 1.18 Support</H2>
	<P>An importer, Analyzer, and Internal changes have been made to support GoLang.  Currently, only version 1.18 is supported; however slightly older or newer versions may work.
	There are still some Decompiler issues with multiple return parameters to be worked out, however the implementation was thought complete enough
	for initial real use.  Please consider the feature an evolving initial implementation.</P>
	
	<H2>Ghidra Startup</H2>
	<P>Ghidra now remembers the last location of a program when it is closed. When that program is later re-opened, Ghidra will position the
	program to that location.  Also, there are options for where Ghidra should start for new programs and optionally when Ghidra completes
	the initial analysis. </P>
	
	<H2>Template Simplification </H2>
	<P>Ghidra now has options for simplifying the display of symbol names, in both the Listing and Decompiler, with complex template information
	embedded in them.  The simplification should result in a much less busy display when dealing with templates. </P>
	
    <H2>Additional Bug Fixes and Enhancements</H2>
    <P> Numerous other bug fixes and improvements are fully listed in the <a href="ChangeHistory.html">ChangeHistory</a> file.</P>
    		   
    <BR>
    <P align="center">
    <B><a href="https://www.nsa.gov/ghidra"> https://www.nsa.gov/ghidra</a></B>
    </P>

  </BODY>
</HTML>
